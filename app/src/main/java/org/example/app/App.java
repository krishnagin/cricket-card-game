/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example.app;

// import org.example.list.LinkedList;
// import static org.example.utilities.StringUtils.join;
// import static org.example.utilities.StringUtils.split;
// import static org.example.app.MessageUtils.getMessage;
import java.io.File;
import java.io.FilenameFilter;
import java.io.IOException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.text.DecimalFormat;
import java.text.NumberFormat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import com.fasterxml.jackson.databind.ObjectMapper;

@SpringBootApplication
@RestController
public class App {

    static ObjectMapper mapper = new ObjectMapper();

    // static File file = new File("C:\\Data\\raw\\ODI-WC\\1144527.json");
    //static File file = new File("C:\\Data\\raw\\ODI-WC\\1144483.json");
    // static File file = new File("C:\\Data\\raw\\ODI-WC\\1144484.json");
    // static File file = new File("C:\\Data\\raw\\ODI-WC\\1144485.json");
    // static File file = new File("C:\\Data\\raw\\ODI-WC\\1144530.json");
    static final boolean doDBCall = true;
    static File directory = new File("C:\\Data\\raw\\ODI-WC");
    static NumberFormat formatter = new DecimalFormat("#0.00");
    // static final String PLAYERS_SQL = "MERGE INTO players WHEN MATCHED THEN UPDATE SET id = ? WHERE name = ? WHEN NOT MATCHED THEN INSERT INTO players (id , name) VALUES(?,?)";
    static final String PLAYERS_SQL = "INSERT INTO players (id, name) VALUES (?,?) ON CONFLICT(id) DO UPDATE SET name = excluded.name";
    static final String PLAYERS_STATS_SQL = "INSERT INTO player_stats_v1 (name, runs, balls, wickets, balls_bowled, runs_given, fifties, hundreds, matches, outs, catches) values (?,?,?,?,?,?,?,?,?,?,?)";
    static final String GET_PLAYER_INFO = "SELECT * FROM player_stats_aggr_v1 WHERE ID= '740742ef'";
    static FilenameFilter filter = (dir, name) -> name.startsWith("1384") || name.startsWith("1144");

    public static void main(String[] args) throws IOException, Exception {

        File[] file = directory.listFiles(filter);
        System.out.println(file.length);

        SpringApplication.run(App.class, args);

        // for(int i = 0; i < file.length; i++) {
        //     System.out.println("file name: " + file[i].getName());
        //     extract_load(file[i]);
        // }
    }

    static void extract_load(File file) throws Exception {
        HashMap<String, String> playerMap = new HashMap<>();

        HashMap<String, Player> players = new HashMap<>();

        ArrayList<String> officials = new ArrayList<>();

        

        final Connection connection = DataBase.getConnection();
        Map<Object, Object> map = mapper.readValue(file, Map.class);

        LinkedHashMap info = (LinkedHashMap) map.get("info");
        LinkedHashMap people = (LinkedHashMap) ((LinkedHashMap) info.get("registry")).get("people");
        ArrayList wickets = new ArrayList<>();
        people.forEach((name, id) -> playerMap.put((String) name, (String) id));
        System.out.println(playerMap);

        LinkedHashMap offical = (LinkedHashMap) info.get("officials");
        if((ArrayList) offical.get("match_referees") != null)
            officials.addAll((ArrayList) offical.get("match_referees"));
        if((ArrayList) offical.get("reserve_umpires") != null)
            officials.addAll((ArrayList) offical.get("reserve_umpires"));
        if((ArrayList) offical.get("tv_umpires")!= null) 
            officials.addAll((ArrayList) offical.get("tv_umpires"));
        if((ArrayList) offical.get("umpires") != null)
            officials.addAll((ArrayList) offical.get("umpires"));

        playerMap.forEach((name, id) -> {
            if (players.get(id) == null && !officials.contains(name)) {
                Player p = new Player(id, name);
                p.addInnings();
                players.put(id, p);
            }
        });

        ArrayList innings = (ArrayList) map.get("innings");
        innings.forEach(inn -> {
            LinkedHashMap i = (LinkedHashMap) inn;
            System.out.println(i.get("team"));
            ArrayList overs = (ArrayList) i.get("overs");
            overs.forEach(over -> {
                LinkedHashMap o = (LinkedHashMap) over;
                ArrayList deliveries = (ArrayList) o.get("deliveries");
                deliveries.forEach(delivery -> {
                    LinkedHashMap d = (LinkedHashMap) delivery;
                    String batter = playerMap.get((String) d.get("batter"));
                    Player pBat = players.get(batter);
                    LinkedHashMap run = (LinkedHashMap) d.get("runs");
                    LinkedHashMap extras = (LinkedHashMap) d.get("extras");
                    String bowler = playerMap.get((String) d.get("bowler"));
                    Player pBowl = players.get(bowler);
                    if (extras != null && (extras.containsKey("wides") || extras.containsKey("noballs"))) {
                        pBat.addRuns((Integer) run.get("batter"), 0);
                    } else {
                        pBat.addRuns((Integer) run.get("batter"), 1);
                        pBowl.addBallsBowled();
                    }
                    if (extras != null && extras.containsKey("legbyes")) {
                        pBowl.addRunsGiven((Integer) run.get("total") - (Integer) extras.get("legbyes"));
                    } else if (extras != null && extras.containsKey("byes")) {
                        pBowl.addRunsGiven((Integer) run.get("total") - (Integer) extras.get("byes"));
                    } else {
                        pBowl.addRunsGiven((Integer) run.get("total"));
                    }

                    boolean bowlerWicket = d.containsKey("wickets") && !((LinkedHashMap) ((ArrayList) d.get("wickets")).get(0)).get("kind").equals("run out");

                    if (bowlerWicket) {
                        pBowl.addWickets();
                    }
                    if ((ArrayList) d.get("wickets") != null) {
                        wickets.addAll((ArrayList) d.get("wickets"));
                    }
                });

            });
        });

        wickets.forEach(w -> {
            LinkedHashMap wMap = (LinkedHashMap) w;
            String pName = (String) wMap.get("player_out");
            String batter = playerMap.get(pName);
            Player pBat = players.get(batter);
            pBat.setOut();

            String kind = (String) wMap.get("kind");
            if ("caught".equals(kind)) {
                ArrayList pList = (ArrayList) wMap.get("fielders");
                pList.forEach(p -> {
                    LinkedHashMap pMap = (LinkedHashMap) p;
                    String fielder = playerMap.get((String) pMap.get("name"));
                    Player pFielder = players.get(fielder);
                    pFielder.addCatch();
                });
            }
        });

        if (doDBCall) {
            try (var pstmt = connection.prepareStatement(PLAYERS_SQL); var statsStmt = connection.prepareStatement(PLAYERS_STATS_SQL)) {
                players.forEach((a, b) -> {
                    b.setMilestones();
                    try {
                        pstmt.setString(1, b.id);
                        pstmt.setString(2, b.name);
                        pstmt.execute();

                        statsStmt.setString(1, b.id);
                        statsStmt.setInt(2, b.runs);
                        statsStmt.setInt(3, b.balls);
                        statsStmt.setInt(4, b.wickets);
                        statsStmt.setInt(5, b.ballsBowled);
                        statsStmt.setInt(6, b.runsGiven);
                        statsStmt.setInt(7, b.fifties);
                        statsStmt.setInt(8, b.hundreds);
                        statsStmt.setInt(9, 1);
                        statsStmt.setInt(10, b.out);
                        statsStmt.setInt(11, b.catches);
                        statsStmt.execute();

                    } catch (SQLException ex) {
                        System.out.println("exception in sql " + ex.getMessage());
                    } 
                    System.out.println(b.toString());
                });
            } catch (Exception e) {
                System.err.println("error occured in stmt update" + e.getMessage());
            } finally {
                if(connection != null){
                    try {
                        connection.close();
                    } catch (SQLException ex) {
                    }
                }
            }
        }

        players.forEach((k, p) -> {
            System.out.println(p.toString());
        });
    }

    static class Player {

        String id;
        String name;
        int runs;
        int balls;
        int innings;
        int fifties;
        int hundreds;
        int catches;
        int wickets;
        int ballsBowled;
        int runsGiven;
        int out;
        static String SEPARATOR = "::";

        Player(String id, String name) {
            this.id = id;
            this.name = name;
        }

        void addRuns(int run, int ball) {
            this.runs += run;
            this.balls += ball;
        }

        void addInnings() {
            this.innings++;
        }

        void setMilestones() {
            if (this.runs >= 50 && this.runs < 100) {
                this.fifties = 1;
            }
            if (this.runs >= 100) {
                this.hundreds = 1;
            }
        }

        double strikeRate() {
            if (this.balls > 0) {
                // Math.(this.runs, this.balls);
                return ((double) this.runs / (double) this.balls) * 100;
            }
            return 0;
        }

        double economy() {
            if (this.ballsBowled > 0) {
                return (double) this.runsGiven / ((double) this.ballsBowled / 6.0);
            }
            return 0;
        }

        void addWickets() {
            this.wickets++;
        }

        void addBallsBowled() {
            this.ballsBowled++;
        }

        void addRunsGiven(int runs) {
            this.runsGiven += runs;
        }

        void setOut() {
            this.out++;
        }

        void addCatch() {
            this.catches++;
        }

        @Override
        public String toString() {
            return this.name + SEPARATOR + this.runs + SEPARATOR + this.balls + SEPARATOR + formatter.format(this.strikeRate()) + SEPARATOR
                    + this.wickets + SEPARATOR + this.ballsBowled + SEPARATOR + this.runsGiven + SEPARATOR + formatter.format(this.economy()) + SEPARATOR
                    + this.fifties + SEPARATOR + this.hundreds + SEPARATOR + this.out + SEPARATOR + this.catches;
        }
    }

    static record PlayerInfo(String id, int matches, int runs, int wickets, int fifities, int hundreds, float avg, float strikeRate, 
    int catches, float economy, float bAvg) {} ;

    static class DataBase {

        static Connection getConnection() {
            try {
                String url = "jdbc:sqlite:C:/Users/dhana/cricket.db";
                return DriverManager.getConnection(url);
            } catch (SQLException ex) {
                System.out.println("exception in getting sqlite connection" + ex.getMessage());
            }
            return null;
        }
    }

    @CrossOrigin(origins = "*")
    @GetMapping("/v1/get-player")
    public Object getRandomPlayerInfo() {
       

        try( Connection conn = DataBase.getConnection();
            var pstmt = conn.createStatement();
            var rs = pstmt.executeQuery(GET_PLAYER_INFO)){
            
            while(rs.next()){
               PlayerInfo p =new PlayerInfo(rs.getString(1),rs.getInt(2),rs.getInt(3),rs.getInt(4),rs.getInt(5),rs.getInt(6),
                rs.getFloat(7),rs.getFloat(8),rs.getInt(9),rs.getFloat(10),rs.getFloat(11));
                return p;
            }
        } catch(Exception e){

        }
    return null;
    }
}
